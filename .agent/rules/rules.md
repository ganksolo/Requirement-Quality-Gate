---
trigger: always_on
---

1. 代码风格与规范 (Code Style)
• 遵循 PEP 8与类型提示：
    ◦ 代码必须符合 Python 标准风格（PEP 8）。
    ◦ 关键函数与公共接口必须包含 Type Hints（类型提示），确保代码意图清晰。
• 命名即文档：
    ◦ 变量与函数命名必须准确表达意图，禁止使用不明含义的缩写（如 data, info, temp）。
    ◦ 使用 snake_case 命名函数和变量，CamelCase 命名类。
• 可读性优先：
    ◦ 避免多层嵌套逻辑（如深层 if/else 或 for 循环），优先使用“提前返回”（Early Return）或列表推导式（在保证可读性的前提下）。
    ◦ 禁止为了简短而牺牲可读性的“一行代码”（One-liners），除非逻辑极度简单。
2. 复杂度控制 (Complexity Control)
• 逻辑原子化：
    ◦ 严格控制函数的圈复杂度。如果一个函数承载了过多的逻辑分支，必须拆分为更小的子函数。
• DRY 原则 (Don't Repeat Yourself)：
    ◦ 发现重复逻辑时，必须将其提取为独立的 Utility 函数、Decorator（装饰器）或 Base Class。
    ◦ 不要在不同模块间复制粘贴相同的逻辑实现。
• 扁平化结构：
    ◦ 分支逻辑超过 2-3 层时，必须进行重构拆分，保持逻辑流线性化。
3. 模块化与架构 (Modularity & Architecture)
• 单一职责原则 (SRP)：
    ◦ 每个 Module（文件）、Class 或 Function 应当只负责一项具体的职责。
    ◦ 禁止创建一个包含所有功能的“上帝对象”（God Object）或 utils.py 垃圾场。
• 明确边界：
    ◦ 模块之间必须保持松耦合。严禁通过“非常规手段”（如直接修改私有属性 _attr）跨层级访问内部状态。
    ◦ 避免循环依赖（Circular Imports），通过合理的目录结构和抽象层级来解决。
• 改动隔离：
    ◦ 修改代码时，影响范围应限制在局部，不得对无关联的模块产生隐式副作用。
4. 设计模式与抽象 (Design Patterns)
• YAGNI (You Aren't Gonna Need It)：
    ◦ 禁止为“未来可能的需求”进行预先优化或过度设计。
    ◦ 仅在当前明显需要扩展性时，才引入策略模式、工厂模式等设计模式。
• 简单优于复杂：
    ◦ 如果一个功能可以使用简单的函数或内置数据结构实现，绝不要引入复杂的类继承体系。
    ◦ 利用 Python 的动态特性（如 Duck Typing）来简化设计，而不是照搬 Java/C# 的严格接口模式。
5. AI 执行指令 (AI Instructions)
• 默认行为：
    ◦ AI 在生成或修改代码时，必须严格遵守上述规范。
    ◦ 当存在“简单实现”与“炫技实现”时，必须选择简单实现。
• 重构建议：
    ◦ 如果 AI 发现现有代码违反了复杂度或模块化规则，应主动建议重构，并提供更清晰的替代方案。
• 一致性维护：
    ◦ 生成的代码必须与当前项目的现有风格保持一致，不要引入项目中未使用的第三方库或异类风格。