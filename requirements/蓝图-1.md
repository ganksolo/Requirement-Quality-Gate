# 蓝图-1

第一份：宏观架构与施工蓝图 (Macro Architecture & Construction Blueprint)

**1. 宏观需求与技术架构 (The Blueprint)**

就像盖楼前必须先看地质报告和效果图，我们需要先定义系统的“边界”和“核心骨架”。

**1.1 宏观业务需求 (Business Requirement)**

我们不是在做一个“聊天机器人”，而是在构建一个**“研发侧的流水线质检机器”**。

- **输入 (Raw Material)**：PM 提供的非结构化素材（录音、聊天记录、简陋的 Ticket、Word 草稿）。
- **黑盒处理 (Processing)**：

◦ **清洗**：把杂乱信息整理成标准 PRD 结构（Structuring）。

◦ **质检**：用代码和 LLM 模拟 Tech Lead 进行评分和拦截（Scoring & Gating）。

- **输出 (Product)**：

◦ **Pass**：结构完整、逻辑闭环、可直接进入开发的 Ticket。

◦ **Reject**：一份包含“阻塞项列表”和“修改建议”的体检报告。

**1.2 宏观技术架构 (Technical Architecture)**

采用 **三层分离架构**，确保系统松耦合，像积木一样可替换。

| 层级 | 类似于大楼的... | 技术选型 | 核心职责 |
| --- | --- | --- | --- |
| **L1: 集成层 (Integration)** | **大门与接待大厅** | **n8n** / Webhook | 负责接收 PM 的输入（Jira/Slack），不处理业务逻辑，只负责透传数据。 |
| **L2: 核心服务层 (Core Service)** | **承重结构与管线** | **FastAPI + LangGraph** | 整个系统的大脑。包含 Agent 编排、状态机流转、规则引擎。 |
| **L3: 基础设施层 (Infra)** | **地基与水电桩** | **Postgres + LLM** | 存储评分记录、审计日志；提供算力（GPT-4o/Gemini）。 |
- -------------------------------------------------------------------------------

**2. 施工步骤分解 (Construction Steps)**

这是你要求的“从地基到水泥”的明确步骤 (#4)。不要试图同时做所有事，严格按此顺序执行：

**第一阶段：地基工程 (Foundation) —— *定义数据契约***

在写任何业务代码前，必须先定义“法律条文”。

- **Step 1.1 锁定 Schema**：定义 `TicketInput`（输入长什么样）和 `ScoreReport`（输出长什么样）。这是系统间通信的唯一标准。
- **Step 1.2 配置规则库 (Rule Config)**：建立 `rubric.yaml`，把“必须有验收标准”、“必须有异常流程”这些规则写进配置文件，而不是代码里。

**第二阶段：框架搭建 (Framing) —— *跑通主流程***

- **Step 2.1 搭建状态机 (DAG)**：使用 LangGraph 串联 `Start -> Guardrail -> Scorer -> Gate -> End` 的路径。此时 Agent 可以是 Mock 的（假数据），目标是跑通整个管线。
- **Step 2.2 实现硬门禁 (Hard Gate)**：编写 Python 函数 `hard_check_gate`，实现“低于 60 分自动拦截”的死逻辑。这是系统的底线。

**第三阶段：填充水泥 (Concrete) —— *注入 Agent 灵魂***

- **Step 3.1 实现 Scoring Agent**：接入 LLM，将 Jira 最佳实践（如 Ticket 十条军规）植入 Prompt。这是 MVP 的核心价值。
- **Step 3.2 实现 Structuring Agent**：让 Agent 学会把“乱序文本”填空到“PRD 模板”中。

**第四阶段：装修与交付 (Decoration) —— *接入与交互***

- **Step 4.1 接入 n8n**：配置 Jira Webhook，让真实用户能触发系统。
- **Step 4.2 美化报告**：将 JSON 报告转化为人类可读的 Markdown 评论回写给 PM。
- -------------------------------------------------------------------------------

**3. 边缘逻辑与异常处理 (Edge Cases Strategy)**

针对你提到的 **#6 边缘逻辑**，这是决定系统是否“皮实”的关键。我们需要建立一张**“负面清单”**。

**3.1 业务层面的边缘案例 (Business Logic Edge Cases)**

这些是**PM 可能会犯的错误**，Agent 必须能够识别并拦截：

- **输入过短/无意义**：

◦ *Case*: PM 只输入了 "RT" 或 "优化一下体验"。

◦ *Handling*: `Input Guardrail` 直接拦截，不消耗 LLM Token，返回 "Input too short"。

- **幻觉性需求**：

◦ *Case*: 需求依赖了一个不存在的系统模块。

◦ *Handling*: 虽然 LLM 难以完全识别，但可以通过 Prompt 要求“列出所有依赖项 (Dependencies)”，强制 PM 确认。

- **自相矛盾**：

◦ *Case*: 标题写“iOS端”，内容写“Web端”。

◦ *Handling*: `Structuring Agent` 标记 `consistency_check` 失败。

**3.2 系统层面的边缘案例 (System Reliability Edge Cases)**

这些是**程序可能会出的问题**，代码必须兜底：

- **LLM 超时/输出截断**：

◦ *Handling*: 设置重试机制（Retry），若 3 次失败，降级为“人工介入模式”，发送报警。

- **JSON 解析失败**：

◦ *Handling*: LLM 有时返回的 JSON 格式错误。使用 Pydantic 的 `Validator` 捕获异常，并触发 LLM 的“自我修正（Self-Correction）”机制。

- **敏感数据泄露**：

◦ *Handling*: 输入输出必须经过 `PII Filter`（个人隐私过滤器），对手机号、密码等字段进行正则脱敏。